# data-stricture-hash

> 散列

## 资源

> [百度百科-Hash](https://baike.baidu.com/item/Hash/390310)
>
>
> [什么是 hash？](https://www.zhihu.com/question/26762707/answer/890181997)
>
> [哈希表（散列表）原理详解](https://blog.csdn.net/yyyljw/article/details/80903391)
> [哈希表（散列表）原理详解](https://blog.csdn.net/duan19920101/article/details/51579136)
>
> [散列函数（哈希）](https://blog.csdn.net/m0_37925202/article/details/82015731)
>
> [散列](https://zhuanlan.zhihu.com/p/136127659)
>
> [散列（哈希）表](https://blog.csdn.net/qq_28119741/article/details/101755925)
>
> [散列表的原理与实现](https://www.jianshu.com/p/01028590ada2)
>
> [散列表（哈希表）的定义](http://www.nowamagic.net/academy/detail/3008010)


## 概述

### 定义

Hash, 散列、杂凑，或音译为哈希, 把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。

其是一种压缩映射, 散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

Hash算法是一个广义的算法，也可以认为是一种思想，Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法。使用Hash算法可以提高存储空间的利用率，可以提高数据的查询效率，也可以做数字签名来保障数据传递的安全性。

若结构中存在和关键字K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为 散列函数（Hash function），按这个事先建立的表为 散列表。

对不同的关键字可能得到同一散列地址，即key1≠key2，而f(key1)=f(key2)，这种现象称碰撞。

具有相同函数值的关键字对该散列函数来说称做同义词。

散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。


### 散列表 (Hash table, 哈希表)

散列表是根据关键码值(Key value)而直接进行访问的数据结构。是散列函数的一个主要应用，使用散列表能够快速的按照关键字查找数据记录。

通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。


散列表散列函数的几乎不可能/不切实际的理想是把每个关键字映射到的索引上（参考散列），因为这样能够保证直接访问表中的每一个数据。

一个好的散列函数（包括大多数加密散列函数）具有均匀的真正随机输出，因而平均只需要一两次探测（依赖于装填因子）就能找到目标。


### 哈希算法分类

1. 直接寻址法

取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）

2. 数字分析法

就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。

3. 平方取中法

取关键字平方后的中间几位作为散列地址。

4. 折叠法

将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。

5. 随机数法

选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。

6. 除留余数法 (除法散列法 )

取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。

不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。

7. 平方散列法

除法是非常频繁的操作，而乘法的运算要比除法来得省时，考虑把除法换成乘法和一个位移操作

8. 斐波那契（Fibonacci）散列法


### 处理冲突方法 (哈希碰撞解决方案)

1. 链地址法 (拉链法)

是使用一个链表数组，来存储相应数据，当hash遇到冲突的时候依次添加到链表的后面进行处理。


2. 开放寻址法 (开放地址法)

是指大小为 M 的数组保存 N 个键值对，其中 M > N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为“开放地址”哈希表。

Hi=(H(key) + di) MOD m,i=1,2,…，k(k<=m-1)，其中H(key)为散列函数，m为散列表长，di为增量序列。

可有下列三种取法:

1). 线性探测法

线性探测法的核心思想是当冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

线性探测法，是比较常用的一种“开放地址”哈希表的一种实现方式。简单来说就是：一旦发生冲突，就去寻找下 一个空的散列表地址，只要散列表足够大，空的散列地址总能找到。

数学表示 : h(k, i) = (h(k, 0) + i) mod m

i 表示当前进行的是第几轮探查, i=1时，即是探查h(k, 0)的下一个；i=2，即是再下一个。这个方法是简单地向下探查。mod m表示：到达了表的底下之后，回到顶端从头开始。

或者 di=1,2,3,…，m-1，称线性探测再散列

2)． 二次探测(Quadratic probing, 二次探测再散列)

di=1^2,-1^2,2^2,-2^2,3^2,…，±k^2,(k<=m/2)

3)．双重散列(Double hashing, 伪随机探测再散列)

di=伪随机数序列。

但是不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。

散列表的装载因子=填入表中的元素个数/散列表的长度。装载因子越大，说明冲突越多，性能越差。

Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。


### 查找性能分析

散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。

对散列表查找效率的量度，依然用平均查找长度来衡量。

查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。

影响产生冲突多少有以下三个因素： 1>. 散列函数是否均匀; 2>. 处理冲突的方法; 3>. 散列表的装填因子。

散列表的装填因子定义为：α = 填入表中的 元素个数/散列表的长度, α是散列表装满程度的标志因子。

由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。


### 散列表

1. 完美散列

  - 布谷鸟散列 (cuckoo hashing)

  - 跳房子散列 (hopscotch hashing)

2. 通用散列法

3. 可扩散列 (extendible hashing)
