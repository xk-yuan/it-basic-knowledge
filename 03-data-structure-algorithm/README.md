# 数据结构与算法 (data structure & algorithm)

> 

## 资源 & 书籍

> [<Algorithms 算法概论 @ Sanjoy 王沛 200807>](#jump-01)

> [<算法导论 第三版 @ Thomas 殷建平 201301>](#jump-02)

> [<数据结构基础 (C语言版) 第二版 @ Ellis 朱仲涛 200903>](#jump-03)

> [<大话数据结构 @ 程杰 201106> / *](#jump-04)
>
>   - [big-talk-data-structure](https://github.com/xknower/big-talk-data-structure)

> [<数据结构与算法分析 (C语言描述) 第二版 @ Mark 冯舜玺 200401> / *](#jump-05)
>
>   - [data-structure-and-algorithm-analysis-in-c-2nd-edition](https://github.com/xknower/data-structure-and-algorithm-analysis-in-c-2nd-edition)
>
>   - <数据结构与算法分析 (JAVA语言描述) 第三版 @ Mark 冯舜玺 201611>
>
>   - [data-structure-and-algorithm-analysis-in-java-3nd-edition](https://github.com/xknower/data-structure-and-algorithm-analysis-in-java-3nd-edition)
>
>   - <数据结构与算法分析 (JAVA语言描述) 第二版 @ Mark 冯舜玺 200901>

## 资源 & 视频

> 表 (顺序表、链表) 

> 栈 

> 队列

> 树
>
> - [平衡二叉排序树|AVL树-从入门到入土@darkwind](https://www.bilibili.com/video/BV1e4411x7rZ)
>
>   - [kmp-模式串、字符串匹配 手动求解next和nextval(前后缀表)](https://www.bilibili.com/video/BV1D441147y8)
>
> - [伸展树Splay Tree](https://www.bilibili.com/video/BV11K4y1Y7AG)
>
> - [数据结构第一讲（绪论）精讲@计算机考研政哥](https://www.bilibili.com/video/BV1bC4y1a7y7)
>
>   - [数据结构精讲--线性表（顺序表）](https://www.bilibili.com/video/BV1mA411i7sa)
>   - [数据结构精讲--线性表--顺序表](https://www.bilibili.com/video/BV16z4y1D7yP)
>   - [数据结构--线性表--习题和算法讲解](https://www.bilibili.com/video/BV1bz4y1D7mN)
>
>   - [数据结构--树和二叉树的基本概念](https://www.bilibili.com/video/BV1Nf4y1R75y)
>
>   - [数据结构精讲--队列](https://www.bilibili.com/video/BV18z4y1D7W9)
>   - [数据结构--栈精讲](https://www.bilibili.com/video/BV1Yp4y1S7fZ)
>
> - [Ershidianlingsan]
>
>   - [23树 & 234树——b树 & b+树(B+ tree)@388098495](https://www.bilibili.com/video/BV1DE411i77d)
>   - [AVL（高度平衡的二叉树）@388098495](https://www.bilibili.com/video/BV1EE411y7aa)
>   - [二叉排序树（二叉搜索树）MOOC@388098495](https://www.bilibili.com/video/BV1Vt411N7Q6)
>
> [完全二叉树判定](https://www.bilibili.com/video/BV16Z4y1u7MC)
>
> [【AgOHの数据结构】平衡树专题之肆 Splay(伸展树)](https://www.bilibili.com/video/BV1wt411u7xL)
>
> [满二叉树、完全二叉树、二叉搜索树、平衡二叉树](https://zhuanlan.zhihu.com/p/106828968)
>
> [红黑树原理及平衡二叉树旋转详解](https://www.bilibili.com/video/BV1X4411p754)
>
>
> [B树和B+树相关](https://www.bilibili.com/video/BV1HZ4y1M7xy)
>
>
>
>
> - [【数据结构】1.4-二叉树与堆](https://www.bilibili.com/video/BV11e411p7jb)

> 堆
>
> - [优先队列PriorityQueue，堆Heap【数据结构和算法入门8】](https://www.bilibili.com/video/BV1ti4y1879c)
>
> [萌新讲解数据结构——堆（Heap）](https://www.bilibili.com/video/BV1up411o7xC)

> 散列
>
> - [day019-哈希查找(散列查找)-算法入门-C语言课堂](https://www.bilibili.com/video/BV114411W7um)
>
> - [带你快速理解 哈希表（散列表）的运作原理@13358869](https://www.bilibili.com/video/BV1MC4y1p7rP)
>
> - [哈希表HashMap【数据结构和算法入门6】](https://www.bilibili.com/video/BV1si4y1b7Rs)
>
> - [数据结构-散列表(Hash Table)@388098495](https://www.bilibili.com/video/BV1dJ411S7iS)

> [详细解析十大排序算法](https://www.bilibili.com/video/BV1WK4y1b7Ee)
>
> [6分钟演示15种排序算法](https://www.bilibili.com/video/BV1Ws411f7aJ)

> 图
>
> - [【数据结构 - 第五讲】图](https://www.bilibili.com/video/BV1X7411j7T9)


> 算法
>
> - [六分钟彻底弄懂希尔排序，简单易懂](https://www.bilibili.com/video/BV1rE411g7rW)
>
> - [希尔排序算法原理 简单易懂动画版](https://www.bilibili.com/video/BV1LT4y137cK)
>
> - [排序算法：插入排序【图解+代码】](https://www.bilibili.com/video/BV1TD4y1Q751)
>
> - [马士兵说：插入排序算法](https://www.bilibili.com/video/BV1kb411x7dw)
>
> - [直接插入，简单选择和起泡排序](https://www.bilibili.com/video/BV125411j7pG)
>
> - [堆排序(heapsort)](https://www.bilibili.com/video/BV1Eb41147dK)
>
> - [归并排序](https://www.bilibili.com/video/BV1Ax411U7Xx)
>
> - [排序算法：归并排序【图解+代码】](https://www.bilibili.com/video/BV1Pt4y197VZ)
>
> - [排序算法：插入排序，快排，归并排序【数据结构和算法入门3】](https://www.bilibili.com/video/BV1QE41177ST)
>
> - [快速排序算法](https://www.bilibili.com/video/BV1at411T75o)
>
> - [快速排序算法](https://www.bilibili.com/video/BV1Tt411r75A)
>
> - [排序算法详解（三）快速排序](https://www.bilibili.com/video/BV1Yt4y1y7R7)
>
> - [图解快速排序quick sort](https://www.bilibili.com/video/BV1Ab411s7To)
>
> - [马士兵说：桶排序-算法思想](https://www.bilibili.com/video/BV1A4411N7cG)

## 资源 & 网站

> [结构算法演示](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)


## 笔记

> 阅读笔记

<span id="jump-01"></span>

### 一、Algorithms 算法概论 @ Sanjoy 王沛 200807

> 算法
> - 时间复杂度
> - 空间复杂度

#### 摘录

> 计算机硬件体系结构

> 初等数学

> 算法研究 : 算法设计思想、模型分析、算法构造、复杂性分析、算法优化

> -> 算术算法、排序算法、简单图论、计算图论、贪心算法、分治算法、线性规划、动态规划、随机算法、NP复杂性理论、量子计算

> 微电子业、芯片制造业

> 十进制位系统 : 数位、字长、算术单元

####  目录

>
> - 第零章    序言
>
> - 第一章    数字的算法
>   - 基本算术
>   - 模运算
>   - 素性测试
>   - 密码学
>   - 通用散列表
> - 第二章    分治算法
>
> - 第三章    图的分解
> - 第四章    图中的路径
>
> - 第五章    贪心算法
> - 第六章    动态规划
> - 第七章    线性规划与归约
> - 第八章    NP-完全问题
> - 第九章    NP-完全问题的处理
> - 第十章    量子计算

> ##### 第一部分 序言

> 1. Fibonacci数列 [0,1,1,2,3,5,8,16,21,34,...]
> (Fn)
![计算规则](imgs/fibonacci数列.png) 

> 时间复杂度 
```
时间复杂度 = 所定义函数的执行次数, 表现为, 随着随着值 (n) 的增加, 调用次数的值。

-> n = 1 ; T(n) = 1
-> n > 1, T(n) = T(n-1) + T(n-2) + 3
=> T(n) 关于 n 是指数级别的

> 1. 指数级别算法
> 2. 多项式算法

计算每个算法的基本操作次数, 并认定基本操作的时间耗费为一个常量, 则以基本操作次数来表征算法的运行时间, 而基本操作次数是算法输入规模的函数。
```




<span id="jump-02"></span>

### 二、算法导论 第三版 @ Thomas 殷建平 201301




<span id="jump-03"></span>

### 三、数据结构基础 (C语言版) 第二版 @ Ellis 朱仲涛 200903

> 数据结构

#### 摘录

> 线性数据结构、树型数据结构、网状数据结构

> 排序算法、查找算法

> 基本数据结构 : 线性表 (数组与链表)、栈、队列、树、图

> 抽象数据类型 (ADT)

> 结构化程序设计

> 算法的规范声明、算法的性能分析、算法的性能评价

> 生命周期 : 需求 -> 分析 -> 设计 -> 编码 -> 验证
> 规范声明
> 分析方法 (自底向上, 自顶向下)
> 设计 (抽象数据类型 + 算法的规范声明和策略)


#### 目录

>
> - 第一章    概论
>   - 数据结构
>     - 抽象数据结构
>   - 算法
>     - 空间复杂度
>     - 时间复杂度
>     - 性能度量
>
> - 第二章    数组和结构
> - 第三章    栈与队列
> - 第四章    链表
> - 第五章    树
> - 第六章    图
>
> - 第七章    排序
> - 第八章    Hash法
> - 第九章    优先级队列
> - 第十章    高效二叉树
> - 第十一章  多路查找树
> - 第十二章  数字查找结构

> ##### 第一部分 概论
```
> 数据类型
> 定义 : 数据类型是数据对象和施加在数据对象上操作的聚合体。

> 包含 : 预定义数据类型, 自定义数据类型
> 操作 :

> 抽象数据类型
> 定义 : 抽象数据类型中的, 数据对象和数据操作的 规范声明, 与, 数据对象的和数据操作的 实现, 相互分离。

> - 数据操作的规范声明
> - 数据操作的实现

> - 构造函数、变换函数
> - 观察函数

```

> ADT 定义 - 定义自然数抽象数据类型 NaturalNumber
```
ADT NaturalNumber
  数据对象 : 有序证书数列, 范围从 0 到机器能够表示的最大整数 (INT_MAX)
  成员函数 :
    以下 x, y ∈ NaturalNumber; TRUE, FALSE ∈ Boolean,
    且 + , - , < , == 是整数类型的操作符。

  NaturalNumber Zero()         : :=    0
  Boolean IsZero(x)            : :=
  Boolean Equal(x, y)          : :=
  NaturalNumber Successor(x)   : := 下一个整数
  NaturalNumber Add(x, y)      : := 相加
  NaturalNumber Subtract(x, y) : := 相减
end NaturalNumber
```

> 性能分析 (空间复杂度, 时间复杂度)
> 性能度量 (获取程序在真实环境下的实际运行时间)
>
> - 空间复杂度 : 程序运行所需的存储空间
>   - 定长空间需求 : 与程序输入输出无关的空间
>   - 变长空间需求 : 实例相关的结构化变量所占空间大小
>   - S(P) = c + Sp(I)
> - 时间复杂度 : 程序运行的时间
>   - 程序步 : 与实例特征无关的, 根据语法或语义划分的程序片段
>   - 渐近复杂度
>     - O(1)  恒定的时间复杂度
>     - O(n)  线性
>     - O(n^2) 次数级别
>     - O(2^n) 指数级别
>     - O(log n)




<span id="jump-04"></span>

### 四、大话数据结构 @ 程杰 201106

>

#### 摘录

> 《如何阅读一本书》
>
> 《大话设计模式》
>
> 摘录书写的过程就是大脑学习的过程, 摘录在于减缓阅读的速度, 从而更好的消化阅读的内容。
> 

> 数据结构 : 相互之间存在一种或者多种特定关系的数据元素的集合。
> 数据结构是一门, 研究非数值计算的程序设计问题中的操作对象, 以及它们之间的关系和操作等相关问题的学科。

> 1968年, 美国的高德纳教授, 在其所写的《计算机程序设计艺术》中, 较为系统的阐述了数据的逻辑结构和存储结构及其操作, 开创了数据结构的课程体系。

> 数据, 是描述客观事物的符号, 是计算机中可以操作的对象, 是能被计算机识别, 并输入给计算机处理的符号集合。
>
> 数据元素, 是组成数据的、有一定意义的基本单位, 在计算机中通常作为整体处理, 也被称为记录。
>
> 数据项, 一个数据元素可以由若干数据项组成。 数据项是数据不可分隔的最小单位。
>
> 数据对象, 是性质相同的数据元素的集合, 是数据的子集。在不产生混淆的情况下, 一般将数据对象简称为数据。
>
> 数据类型 : 指一组性质相同的, 值的集合及定义在此集合上的一些操作的总称。类型就是用来说明, 变量或表达式的取值范围和所能进行的操作。
> (C语言 : 原子类型, 结构类型)


> 抽象 : 指抽取出事物具有普遍性的本质, 是抽出问题的特征而忽略非本质的细节从而对具体事物的概括。

> 

#### 目录

>
> - 第一章    绪论
> - 第二章    算法
>
> - 第三章    线性表
> - 第四章    栈与队列
> - 第五章    串
> - 第六章    树
> - 第七章    图
>
> - 第八章    查找
> - 第九章    排序

> ##### 第一部分 绪论&算法

> 数据结构
> ![](imgs/大话数据结构_绪论_数据结构分类.png)
>
> - 1. 逻辑结构 : 指数据对象中数据元素之间的相互关系
>
>> 逻辑结构是面向问题的, 物理结构是面向计算机的, 其基本目的是将数据及其逻辑关系存储到计算机的内存中。
>
>   - a. 集合结构 : 数据元素之间除了同属于一个集合, 没有其他关系
>![](imgs/大话数据结构_绪论_集合结构.png)
>
>   - b. 线性结构 : 数据元素之间是一对一的关系
>![](imgs/大话数据结构_绪论_线性结构.png)
>
>   - c. 树性结构 : 数据元素之间存在一对多的层次关系
![](imgs/大话数据结构_绪论_树性结构.png)
>
>   - d. 图结构   : 数据元素之间是多对多的关系
>![](imgs/大话数据结构_绪论_图结构.png)
>
>
> - 2. 物理结构(存储结构) : 数据的逻辑结构在计算机中的存储形式 (数据元素的存储结构应正确反映数据元素之间的逻辑关系)
>
>   - a. 顺序存储结构: 数据元素存放在地址连续的存储单元里, 其数据间的逻辑关系和物理关系一致
>![](imgs/大话数据结构_绪论_顺序存储结构.png)
>
>   - b. 链式存储结构 : 数据元素存放在任意的连续或不连续存储单元里。 此时数据存储关系不能反映其逻辑结构, 因此需要使用一个指针存储数据元素的地址
>![](大话数据结构_绪论_链式存储结构.png)
>

> 抽象数据结构 (Abstract Data Type, ADT) : 指一个数学模型及定义在该模型上的一组操作。
> 
> 抽象数据类型 : 一个抽象数据类型, 定义了, 一个数据对象、数据对象中各数据元素之间的关系及数据元素的操作。其体现了程序设计中问题分解、抽象和信息隐藏的特性。
>

> 描述抽象数据类型的标准格式
``` []
ADT 抽象数据类型名

Data
    数据元素之间的逻辑关系的定义

Operation
    操作 1
        初始条件
        操作结果描述
    ...
    操作 n
        初始条件
        操作结果描述
End ADT
```

![](imgs/大话数据结构_绪论_数据结构组成.png)


> 算法 : 解决特定问题求解步骤的描述, 在计算机中表现为指令操作的有限序列。即描述解决问题的方法。

> 算法的基本特性
>
> - a. 输入
> - b. 输出
> - c. 有穷性 : 指算法在执行有限的步骤之后, 自动结束而不会出现无限循环, 并且每个步骤在可接受的时间内完成。
> - d. 确定性 : 算法的每一步都具有确定的含义, 不会出现二义性。
> - e. 可行性 : 算法的每一步都必须是可行的, 也就是说, 每一步都能够通过执行有限次数完成。

> 算法的要求
>
> - a. 正确性 : 算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够的到问题的正确答案。
>   - 1. 算法没有语法错误
>   - 2. 算法对合法输入有正确的输出结果
>   - 3. 算法对合理的非法输入有满足规格说明的结果
>   - 4. 算法对异常输入的测试数据都有满足要求的输出结果
> - b. 可读性 : 能便于阅读、理解和交流
> - c. 健壮性 : 当输入不合法是, 算法也能做出相关处理, 而不是产生异常或未知的结果
> - d. 执行时间效率高
> - e. 消耗存储空间低

> 算法效率度量方法 : 执行时间主要取决于, 算法的好换和问题的输入规模
>
> - 函数的渐近增长 : 给定两个函数 f(n) 和 g(n), 如果存在一个整数 N, 使得对于所有的 n > N, f(n) 总是比 g(n) 大, 那么, 就说 f(n) 的增长渐近快于 g(n)。
>
> 通过算法时间复杂度来估算算法时间效率
>
> 时间复杂度 : 在进行算法分析时, 语句总的执行次数 T(n) 是关问题规模 n 的函数, 进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度, 也就是算法的时间度量, 记作 T(n) = O(f(n))。它表示随着问题规模 n 的增大, 算法执行时间的增长率和 f(n) 的增长率相同, 称作算法的渐近时间复杂度, 简称时间复杂度。
> - 常数阶 O(1)
> - 线性阶 O(n)
> - 平方阶 O(n^2)
> - 对数阶 O(log n)
>![](imgs/大话数据结构_算法_常见的时间复杂度.png)
>![](imgs/大话数据结构_算法_常见的时间复杂度_耗费时间关系.png)
> 分析算法的复杂度, 关键就是分析循环结构的运行情况
>
> 空间复杂度
>

> ##### 第二部分 




<span id="jump-05"></span>

### 五、数据结构与算法分析 (JAVA语言描述/C语言描述) @ Mark 冯舜玺

>

#### 摘录

> 离散数学

> 设有一组 N 个数, 而确定其中第 k 个 最大者, 称之为 选择问题 (selection problem)。

> 算法 : 是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。

#### 目录

>
> - 第一章    概论
> - 第二章    算法分析

>
> - 第三章    表、栈、队列
>
>   - ADT
>   - 表   : 顺序表(数组 array)、链表 (linked list)
>   - 栈
>   - 队列
>
> - 第四章    树
>
>    - 概念
>    - 二叉树
>    - 查找树
>    - AVL 树
>    - 伸展树
>    - B 树
> 
> - 第五章    散列
> - 第六章    堆

>
> - 第七章    排序
> - 第八章    不相交集
> - 第九章    图论算法

>
> - 第十章    算法设计技巧
> - 第十一章  摊还分析
> - 第十二章  高级数据结构及其实现

##### 第一部分 概论 & 算法分析

> 概念叙述和JAVA基础

> 案例及其算法时间复杂度分析

> JAVA 基础 & 泛型 (generic) & 函数对象
>
> 1. 使用继承的基本原则来实现泛型方法和类, 使用像Object这样的超类来实现泛型类
>
> 2. 函数对象
>
> 自动装箱 : 如果int型变量传递到需要Integer对象的地方, 编译器将自动插入一个对Integer构造方法的调用
> 自动拆箱 ： 如果Integer型变量传递到需要int对象的地方, 编译器将自动插入一个对intValue()构造方法的调用
>
> 泛型, 由编译器支持而不是运行环境, 编译器通过类型擦除, 将泛型类转变为非泛型类。


##### 第二部分 - 表 (顺序表、链表) / 栈 / 队列

>###### 抽象对象类型(Abstract Data Type, ADT), 是带有一组操作的一些对象的集合。

>###### 表
>
> 1. 操作
>
>   - 查找
>   - 插入
>   - 删除
>   - 替换
>
> 栈 (特殊表)
>
> 1. 操作
>
>   - 进栈
>   - 出栈
>
> 队列 (特殊表)
>
> 1. 操作
>
>   - 入队
>   - 出队


>###### 链表 (linked list)
>
> - 单链表 : next 链 : 链表由一系列节点组成, 节点不必在内存中相连。每一个节点均含有表元素和包含该元素后继元的节点的链 (link)。
>![](imgs/数据结构与算法分析_表_链表_next链.png)
>
> - 双链表(doubly linked list) :
>![](imgs/数据结构与算法分析_表_链表_双向链表.png)


>###### JAVA 中表 ( JAVA Collections API) / 集合 -> 表 -> 顺序表、链表
>
> - Collection 接口 : 集合, 存储一组类型相同的对象
>
> - Iterable 接口 : 迭代器 , 使用增强fro循环遍历时间该接口的集合元素对象
>
> - Comparator 接口
>
> - List 接口
>
>   - ArrayList  类
>
>   - LinkedList 类
>
> - ListIterator 接口
>   - Iterator
> - PrimitiveIterator
>   - Iterator
>
> 关系结构
>
> List -> Collection -> Iterable
>
> ArrayList -> List
>
> LinkedList -> List


>###### 栈 (stack) (LIFO, 后进先出表)
>
> 栈, 是限制插入和删除只能在一个位置上进行的表, 该位置是表的末端。叫做顶 (top), 对栈的基本操作有 push(进栈) 和 pop (出栈)。
>
>![](imgs/数据结构与算法分析_表_栈模型.png)
>![](imgs/数据结构与算法分析_表_栈模型_01.png)
>
> 由于栈是一个特殊表, 因此任何实现表的方法都能实现栈。栈操作都是常数时间, 实现可使用, 单链表, 数组实现。


>###### JAVA 中表 ( JAVA Collections API) / 栈(特殊表)
>
> - [java.util.Stack] 类
>
>   - Vector
>
> - [java.util.Vector] 类
>  - AbstractList
>  - AbstractCollection
>  - List
>  - RandomAccess Cloneable Serializable


>###### 队列 (queue)
>
> 队列, 在一端插入在另一端删除的特殊表。基本操作是 入队(enqueue), 在表的末端插入元素, 出队(dequeue), 在表的开头删除并返回元素。
>
> 由于队列是一个特殊表, 因此任何实现表的方法都能实现队列。
>
>![](imgs/数据结构与算法分析_表_链表_双向链表.png)
>
>

>###### JAVA 中表 ( JAVA Collections API) / 队列(特殊表)
>
> - [java.util.Queue] 接口
>
>   - Collection
>
> - [java.util.Deque] 接口 (双向队列)
>
>   - Queue
>
> - [java.util.BlockingQueue] 接口 (阻塞队列)
>
>   - Queue

> - [java.lang.Comparable] 接口 // 可比较的

##### 第二部分 - 树

> 对于大量的输入数据, 链表的线性访问太慢, 不适宜使用。

> 二叉树, 是集合库类 TreeSet 和 TreeMap 实现的基础。

> 树, 可以用几种方式定义。定义树的一种自然的方式是递归的方式。
> 一个树是一些节点的集合。树由根(root)节点 r 以及零个或者多个非空的子树 T1, .., Tk 组成,
> 这些子树中的每一棵的根都被来自 r 的一条有向边(edge)所连结。
> ![](imgs/数据结构与算法分析_表_树模型.png)
> ![](imgs/数据结构与算法分析_表_树模型_01.png)
> ![](imgs/数据结构与算法分析_表_树模型_02.png)

> 自平衡二叉查找树(高度平衡树) : 在AVL树中任何节点的两个子树的高度最大差别为 1, 增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

>###### 树 (tree)
>
> - 树
>
> 实现树的一种方式是, 在每个节点中除数据外, 还要包含一些链, 使得该节点的每一个子节点都有一个链指向它。 
>
> ![](imgs/数据结构与算法分析_表_树模型_树应用_UNIX文件系统.png)
>
> - 二叉树 (binary tree) : 每个节点都不能有多于两个的子节点。
>
> ![](imgs/数据结构与算法分析_表_树模型_二叉树.png)
>
> 二叉树的一个性质是, 一颗平均二叉树的深度要比节点个数N小的多。 
>
> ![](imgs/数据结构与算法分析_表_树模型_二叉树_定义.png)
>
> 二叉树的主要用处之一, 实在编译器的设计领域。
>
> - 二叉查找树 (binary search tree)
>
> - AVL 树 (adelson-velskii-landis) (平衡树)
>  带有平衡条件(balance condition)的二叉查找树。
>
> - 伸展树 (splay tree)
>
>   保证从空树开始, 连续M次队树的操作最多 O(MlogN)时间。伸展树的基本思想是, 当一个节点被访问后, 它就要经过一些列AVL树的旋转被推到根上。
>
> - B 树
>
> B树保证只有少数的磁盘访问

> 树遍历
>
> - 先序遍历 (preorder traversal)
>
> - 后序遍历 (postorder traversal)
>
> - 中序遍历 (inorder traversal)


```
Set        // 接口, 不允许重复的元素
SortedSet  // 接口, 特殊的Set, 排序保证数据元素处于有序的状态
TreeSet    // (平衡二叉树实现)

TreeMap    // (平衡二叉树实现)
```

>###### JAVA 中表 ( JAVA Collections API) / 无序列表
>
> - [java.util.Set] 接口
>
>   - Collection
>
> - [java.util.SortedSet] 接口
>
>   - Set
>
> - [java.util.NavigableSet]
>
>   - SortedSet
>
> - [TreeMap]
>

##### 第二部分 - 散列

> 散列表 (Hash Table), 一种用于以常数平均时间插入、删除和查找的技术。

> 理想的散列表数据结构, 只不过是一个包含一些项的具有固定大小的数组。

> 散列函数 (Hash Function), 

>![](imgs/数据结构与算法分析_表_散列表.png)

> 闪存散列代码 (caching the hash code)

###### 散列 (Hash)

> 散列函数

> 解决冲突
>
> - 分离链接法 (separate chaining) : 将散列到同一个值的所有元素, 保存到一个表中。
>
> ![](imgs/数据结构与算法分析_表_散列表_分离链接散列表.png)
>
> - 不用链表的散列表
>
>   - 探测散列表 (线性探测法、平方探测法)
>
>   - 双散列
>
> - 完美散列
> ![](imgs/数据结构与算法分析_表_散列表_使用二级散列表的完美散列.png)
>
> - 布谷鸟散列 (cuckoo hashing)
>
> - 跳房子散列 (hopscotch hashing)
>
> - 通用散列法
>
> - 可扩散列 (extendible hashing)

```
Map        // 接口, 表示由关键字及它们的值组成的一些项的集合, 关键字唯一, 值不唯一
SortedMap  // 接口, 映射关键字保持逻辑上的有序状态
HashMap

HashSet
```

>###### JAVA 中表 ( JAVA Collections API) /
>
> -  [java.util.Map] 接口
>
> - [java.util.SortedMap] 接口
>
>   - Map
>
> - [java.util.ConcurrentMap] 接口
>
>   - Map
>
> - [java.util.NavigableMap]
>
>   - SortedMap
>
> - [HashMap]  // 分离链接散列实现, 必须提供 equals 和 hashCode 实现
>
> - [HashSet]  // 分离链接散列实现, 必须提供 equals 和 hashCode 实现

> - [PriorityQueue] // 优先队列(堆)

##### 第二部分 - 堆 (优先队列)

> 贪婪算法(greedy algorithm), 的实现方面优先队列也是很重要的, 该算法通过反复求出最小元来进行操作。

> 有多种优先队列的实现, 第一种, 可以使用简单链表, 在表头以O(1)执行插入操作, 并遍历该链表以O(N)删除最小元。
> 另一种式, 使用二叉查找树, 其对插入和删除的平均运行时间都是O(logN)。

> 除不能实施 find 外, 堆实现的最明显的缺点是, 将两个堆合并成一个堆是困难的操作。

> - 满二叉树 : 一棵深度为 k 且有 2^K - 1 个结点的二叉树称为满二叉树。

> - 完全二叉树 : 棵深度为k的有n个结点的二叉树，"对树中的结点按从上至下、从左到右的顺序进行编号"，如果编号为i(1≤i≤n)的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树。
> 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。

###### 堆

> 优先队列 (priority queue)
> ![](imgs/数据结构与算法分析_表_优先队列.png)
> 
> - 二叉堆 (binary heap)
>
>   - 结构性 : 堆是一颗完全被填满的二叉树。这样的树, 称之为完全二叉树(complete binary tree)。
>   ![](imgs/数据结构与算法分析_表_堆_完全二叉树.png)
>   因为完全二叉树的规律性, 所以它可以用一个数组表示而不需要使用链。
>   ![](imgs/数据结构与算法分析_表_堆_完全二叉树_数组实现.png)
>   堆结构, 由一个(Comparable对象)数组和一个代表当前堆的大小的整数组成。
>
>   - 堆序性 (heap-order property) : 任意节点都应该小于它的所有后裔。
> 
> 插入 : 上滤 (percolate up), 新元素在堆中上滤, 直到找出正确的位置
> 删除 : 下滤 (percolate down)
>
> - d-堆 : 是二叉堆的简单推广, 只是所有的节点都有d个儿子。使用在当优先队列很大而不能完全装入内存时。
>![](imgs/数据结构与算法分析_表_堆_d-堆.png)
>
> - 左式堆 (leftist heap) : 和二叉堆一样也具有结构性和有序性, 也是二叉树。但区别是, 其不是理想平衡的, 而实际上式趋于非常不平衡的。
>
>   - 堆性质 : 任意一个节点 X 的零路长(null path length) npl(X), 定义为从 X 到一个不具有两个儿子的节点的最短路径长。
>   对于堆中的每一个节点 X, 左儿子的零路长至少与右儿子的零路长相等。
>   左式堆的基本操作是合并(merge),  而插入只是合并的特殊情形。
>
> - 斜堆 (skew heap) : 是左式堆的自调节形式。其式具有堆序的二叉树, 但不存在堆树的结构限制。
>
> - 二项队列 (binomial queue) : 其不是一个堆序的树, 而是堆序的树的集合, 称为森林(forest)。每一个堆序树都是有约束的形式, 称为二项树(binomial tree)。
>


##### 第三部分 - 算法 - 排序

> 内部排序 (主存中排序, 数据比较小(小于几百万))
>
> 外部排序 (external sorting)


> - 插入排序 (insertion sort)
>
> - 希尔排序 (sell sort)
>
> - 堆排序 (heap sort)
>
> - 归并排序 (merge sort)
>
> - 快速排序 (quick sort)
>
> - 快速选择 : 解决选择问题(selection problem), 
>
> - 线性时间排序
>
>   - 桶排序 (bucket sort)
>
>   - 基数排序 (radix sort)
>
> - 外部排序 (external sorting)


> 基于比较的排序 (comparison-based sorting)

> 归并排序, 是经典的分治(divide-and-conquer)策略, 其将问题分(divide)成一些小的问题, 然后递归求解, 而治(conquer)阶段则将分的阶段的解合并到一起。

> 任何只要用到比较的算法, 在最坏情况下都需要 O(NlogN)次比较, 因此归并排序和堆排序在一个常数因子范围内是最优的。快速排序在相差一个常数因子的范围内是最优的。

> 决策树 (decision tree), 是用于证明下界的抽象概念。

> 排序是计算中最古老、被研究的最完备的问题之一。

> 插入排序合适非常小量的数据, 对于中等规模的数据使用希尔排序更好, 归并排序比较次数是最优的其最坏为O(NlogN)实现但需要额外空间, 快速排序几乎肯定可以做到O(NlogN)。
> 基数排序可以将字符串在线性时间内排序。

>###### 排序
>
> - 插入排序 (insertion sort) : O(N^2), 由N-1趟排序组成, 对于 p=1到N-1趟, 插入排序保证从位置0到p上的元素为已排序状态。
>
> - 希尔排序 (sell sort) : O(N^2)
>
> - 堆排序 (heap sort) :
>
>   优先队列可以用以O(NlogN)时间排序, 该思想的算法叫做堆排序。该算法的主要问题在于使用了一个附加的数组, 因此存储需求增加一倍。
>   回避使用第二个数组的方式是, 每次deleteMin后, 堆缩小1, 因此位于堆最后的单元可以用来存放刚刚删去的元素。
>
> - 归并排序 (merge sort) : O(NlogN), 基本操作是合并两个已排序的表。将输出放到第三个表时, 该算法可以通过对输入数据一趟排序来完成。
>
>   其有一个明显的问题, 就是合并两个已排序表用到线性附加内存, 并要花费将数据拷贝到临时数组在拷贝回来的附加工作。
>
> - 快速排序 (quick sort) : O(NlogN), 一种快速的排序算法, 得益于其非常精炼和高度优化的内部循环。其也是一种分治递归算法。
>
> - 外部排序 (external sorting) : 由于输入数据量太大而不能装入内存, 需要使用外部排序。处理输入很大的输入数据。
>
>   基本的外部排序算法, 使用归并排序中的合并算法。
>
>   - 多路合并
>
>   - 多相合并
>
>   - 替换选择 (replacemenet selection)

>###### 不相交集类

> 描述解决等价问题的一种有效数据结构。
>
> 等价关系 (equivalence relation)


##### 第四部分 - 图

> 斐波那契堆 (Fibonacci heap)

>###### 图 (graph)

>![](imgs/数据结构与算法分析_图_思维导图.png)

1. 逻辑结构
    - 图的定义
    - 相关概念

>定义 : 图G由顶点集和边集E组成, 记 G = (V, E), 其中 V(G)表示图 G 中顶点的有限非空集： E(G) 表示图G中顶点之间的关系(边)集合。
>
>|V| 表示图HG中顶点的个数, 也称为图阶; |E| 表示图G中边的条数。

>![](imgs/数据结构与算法分析_图.png)
>图 : G = (V, E);
> 顶点集合 : V={A,B,C,D,E};
> 边集合 : E={(A,B),(A,C),(A,E),(B,C),(C,D),(C,E)}

- 图分类
  - a.
    - 无向图 : 表示所有边, 都是无向边
    > ![](imgs/数据结构与算法分析_图_无向图.png)
    >
    > 连通 : 若从顶点v到顶点w有路径存在, 则成v和w是连通。
    > ![](imgs/数据结构与算法分析_图_连通.png)
    > ![](imgs/数据结构与算法分析_图_无向图_连通图.png)
    > 无向连通图, n 个顶点最少有多少边 : n- 1 条边
    >![](imgs/数据结构与算法分析_图_无向图_连通图_最少边.png)
    >
    > 连通分量(极大连通子图) : 对于G的一个(强)连通子图G', 如果不存在G的另一个(强)连用子图G'',使得G'< G'', 则称G'为G的(强)连通分量。在(强)连通的情况下, 尽可能包含最多的边。
    > 极小连通子图 : 在(强)连通的情况下, 尽可能包含最少的边。
    >
    > 生成树 : 连通图包含全部顶点的一个极小连通子图。
    >![](imgs/数据结构与算法分析_图_无向图_连通图_生成树.png)
    >
    > 生成森林 : 非连通图, 所有连通分量的生成树组成生成森林
    > ![](imgs/数据结构与算法分析_图_无向图_连通图_生成森林.png)
    >

    - 有向图 : 表示所有边, 都是有向边。此时边也称为弧。
    > ![](imgs/数据结构与算法分析_图_有向图.png)
    >
    > 强连通 : 若从顶点v到顶点w 和 顶点w到顶点v都有路径存在, 则称 v 和 w 是强连用。有方向相反的两条路径。
    > ![](imgs/数据结构与算法分析_图_有向图_强连通.png)
    > ![](imgs/数据结构与算法分析_图_有向图_强连通图.png)
    > 有向强连通图, n 个顶点最少有多少边 : n 条边
    > ![](imgs/数据结构与算法分析_图_有向图_强连通图_最少边.png)
    >
    > 强连通分量(极大强连通子图) : 连通分量(极大连通子图) : 对于G的一个(强)连通子图G', 如果不存在G的另一个(强)连用子图G'',使得G'< G'', 则称G'为G的(强)连通分量。在(强)连通的情况下, 尽可能包含最多的边。
    >
  
  - b.
    - 简单图 : 无重复的边, 且不存在节点到自身的边
    > ![](imgs/数据结构与算法分析_图_简单图.png)
    - 多重复图 : 存在重复的边, 或存在节点到自身的边
    > ![](imgs/数据结构与算法分析_图_多重图.png)
  
  - c. 完全图
    - 无向完全图 : 无向图, 且任意两个顶点都存在边
    >![](imgs/数据结构与算法分析_图_无向完全图.png)
    > 边数 : n 个顶点有 n(n-1)/2 边
    - 有向完全图 : 有向图, 且任意两个顶点都存在方向相反的两条弧
    >![](imgs/数据结构与算法分析_图_有向完全图.png)
    > 边数 : n 个顶点有 n(n-1) 边

  - d.
    - 稀疏图 : 界定 : |E| < |V| log |V|
    - 稠密图

>子图 : 设有两个图 G=(V,E) 和 G'=(V',E'), 若V'是V的子集, 且E'是E的子集, 则称G'为G的子图。 且若, V(G)=V(G') 则称G'为G的生成子图。

>![](imgs/数据结构与算法分析_图_子图_子图.png)
>![](imgs/数据结构与算法分析_图_子图_子图_01.png)
> 子图

>![](imgs/数据结构与算法分析_图_子图_生成子图.png)
> 生成子图

> 顶点的度 : 以顶点为一个端点的边的数目。

> 网 : 为边增加权重

> 有向树 : 一个顶点的入度为0、其余顶点的入度为1的有向图。
>![](imgs/数据结构与算法分析_图_有向图_有向树.png)

> 路径 : 图中顶点v到顶点w的顶点序列。序列中顶点不重复的路径称为简单路径。
>
> 路径长度 : 路径上边的数目, 若该路径最短则称其为距离。
>
> 回路 : 特殊的路径, 第一个顶点和最后一个顶点相同的路径。


2. 存储结构及操作
  - 领接矩阵法 : 空间复杂度 O(n^2), 适用于稠密图。使用顺序存储结构存储。
  - 邻接表法 : 空间复杂度 O(|V|+|E|) / O(|V|+2|E|), 适用于稀疏图。顺序存储 + 链式存储。
  - 十字链表
  - 邻接多重表

> 领接矩阵

![](imgs/数据结构与算法分析_图_存储结构_邻接矩阵法_定义.png)
![](imgs/数据结构与算法分析_图_存储结构_邻接矩阵法_定义_带权重.png)

![](imgs/数据结构与算法分析_图_存储结构_邻接矩阵法_有向图.png)
![](imgs/数据结构与算法分析_图_存储结构_邻接矩阵法_无向图.png)

> 邻接表法

> 十字链表 : 针对有向图的一种链式存储结构。

> 邻接多重表 : 针对于无向图的一种链式存储结构。


> 图的基本操作
>
> - Adjacent(G, x, y) : 判断 G 是否存在边 <x,y> 或 (x,y)
>
> - Neighbors(G, x) 列出图G中与结点x邻接的边
>
> - InsertVertex(G,x) 在图G中插入顶点 x
>
> - DeleteVertex(G,x) 从图G中删除顶点 x
>
> - AddEdge(G,x,y) 若无 


3. 图遍历
  - 广度优先遍历 (BFS) : 空间复杂度 O(|V|), 时间复杂度 : 邻接矩阵 O(|V|^2), 邻接表法 O(|V|+|E|)
  - 深度优先遍历 (DFS) : 空间复杂度 O(|V|),  时间复杂度 : 邻接矩阵 O(|V|^2), 邻接表法 O(|V|+|E|)
  - 遍历与连通性

  - 深度优先生成树(森林) ： 在深度遍历过程中, 可以得到一棵遍历树

4. 图应用
  - 最小生成树
  - 最短路径
  - 拓扑排序
  - 关键路径

> 图 : 图 G = (V,E) 由顶点(vertex)的集V和表(edge)的集合E组成。每一条边就是一幅点对(v,w)。
>
>   - 路径 : 图中的一条路径(path)是一个顶点序列 W1,W2,...,Wn 使得(Wi,Wi+1) <- E, 1<=i< n; 这条路径的长是为该路径上的边数, 等于 n-1。

> 图表示
>
>   - 邻接矩阵 (adjacent matrix) : 空间需求 O(|V|^2)。可以使用简单方式, 即使用一个二维数组表示。
>
>   - 邻接表 (adjacency list) : 空间需求 O(|E| + |V|), 相对图的大小是线性的。当图是稀疏的(sparse)时使用, 邻接矩阵的空间需求很大, 因此当边不是很多使用该方法表示。
>![](imgs/数据结构与算法分析_图_邻接表示法.png)

> - 拓扑排序 : 对有向无圈图的一种排序, 使得如果存在一条 vj 到 vj 的路径, 那么排序中 vj 就出现再 vi 后面。

> - 最短路径算法
>
>   - 无权最短路径
>
>   - 广度优先搜索 (breadth-first search) : 该方法按层处理顶点, 距开始点最近的那些顶点首先被求值, 而最远的那些顶点最后被求值。
>
>   - Dijkstra 算法 ：解决单源最短路径问题。 
>
>   - 贪婪算法 (greedy algorithm)
>
>   - 关键路径分析法 (critical path analysis)
>
>   - 深度优先搜索 (depth-first search) : 是对先序遍历的推广。


##### 第五部分

>

> 贪婪算法 (greedy algorithtm)
>
>   - Dijkstra
>   - Prim
>   - Kruskal
>
>   - trie 树
>     - 前缀码 (prefix code)
>
>   - 哈夫曼编码 (Hufman code)
>

> 分治算法 (divide and conquer)
>
>   - 分 (divide) : 递归解决较小的问题 (基本问题除外)
>   - 治 (conquer) : 然后从子问题的构建原问题的解

> 动态规划 (dynamic programming)

> 随机算法 (randomized algorithm)

> 回溯算法 (backtracking)


##### 第六部分

>

> 斐波那契堆

> 伸展树

##### 第七部分


> 自顶向下伸展树

> 红黑树

> treap 树

> 后缀数组与后缀树

> k-d 树

> 配对堆
